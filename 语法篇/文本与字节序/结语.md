# 结语

## 编码

关于编码实际上除了文本文件,几乎所有数据都要有格式有编码.MP3,jpg都是编码方式,
也就是按照统一蓝本描绘内容的数据.正因为有了编码我们才能区别数据的类型.数据才能被人类所使用.

## python 在内存中如何表示字符串

Python 官方文档对字符串的码位在内存中如何存储避而不谈.毕竟,这是实现细节.理论上,怎么存储都没关系：不
管内部表述如何,输出时每个字符串都要编码成字节序列.
在内存中,Python3使用固定数量的字节存储字符串的各个码位,以便高效访问各个字符或切片.
在Python 3.3 之前,编译CPython 时可以配置在内存中使用16 位或32 位存储各个码位.

+ 16 位是"窄构建"（narrow build）
+ 32 位是"宽构建"（wide build）.

如果想知道用的是哪个,要查看`sys.maxunicode` 的值--65535 表示"窄构建",不能透明地处理`U+FFFF`以上的码位.
"宽构建"没有这个限制,但是消耗的内存更多：每个字符占4个字节,就算是中文象形文字的码位大多数也只占2 个字节.
这两种构建没有高下之分,应该根据自己的需求选择.


从Python 3.3 起,创建str对象时,解释器会检查里面的字符,然后为该字符串选择最经济的内存布局：

+ 如果字符都在latin1 字符集中,那就使用1 个字节存储每个码位
+ 否则,根据字符串中的具体字符,选择2 个或4 个字节存储每个码位.
这是简述,完整细节参阅["PEP 393—Flexible String Representation"](https://www.python.org/dev/
peps/pep-0393/).
灵活的字符串表述类似于Python 3 对int 类型的处理方式：如果一个整数在一个机器
字中放得下,那就存储在一个机器字中；否则解释器切换成变长表述,类似于Python 2
中的long 类型.这种聪明的做法得到推广,真是让人欢喜!



## 序列化

本文介绍的序列化工具除了pickle基本都是类似json这种可以自我表示的类型.而工业上在分布式系统中使用更多的可能还是类似pickle这样需要
有文件标识结构化数据的序列化方案(pickle可以看作是使用python代码标识结构化数据).当然了pickle无法跨语言不具备通用性.
这类工具的代表是[Protobuf](https://github.com/google/protobuf)和[Thrift](https://github.com/apache/thrift).他们都有python接口.
本文之所以不做介绍主要是因为其无法自治,并不符合python的特点,这种方式强调转换后字节数要短,以便更快的传输.但因为其无法自治,调试会很不方便,
也会为版本管理带来额外的复杂度.


## 相关扩展和模块

+ [xpinyin](https://github.com/lxneng/xpinyin)

    一个将中文转换为拼音的工具.